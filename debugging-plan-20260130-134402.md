# Debugging Plan: Test Suite Hang After Timeout Policy Test

**Generated**: 2026-01-30 13:44:02 UTC  \
**Issue ID**: PR-320-hang  \
**Severity**: High (CI timeout)

## Problem Statement

After modifying `test_overflow_policy_timeout` to block the worker thread until
back-pressure is created, the test suite can hang for ~13 minutes before CI
terminates. The expected behaviour is that the suite completes within the
standard timeout. The hang appears during Rust tests (rotating handler
behaviour) and Python-related tests, suggesting a deadlock or resource
contention introduced by the new test.

## Context Summary

| Aspect | Details |
|--------|---------|
| First observed | After PR 320 changes to `test_overflow_policy_timeout` |
| Reproduction rate | Intermittent; reported in CI (13-minute timeout) |
| Affected components | Python formatter path, file handler worker threads, rotating handler tests |
| Recent changes | New blocking Python formatter + indefinite wait in test |

### Error Artefacts

```
... ok
... ok
... ok
... ok
test handlers::rotating::tests::behaviour::before_write_reports_rotation_outcome has been running for over 60 seconds
test handlers::rotating::tests::behaviour::rotate_falls_back_to_append_when_reopen_fails has been running for over 60 seconds
test python::tests::falls_back_when_attrs_missing has been running for over 60 seconds
test python::tests::returns_builtin_name_without_module has been running for over 60 seconds
make: *** [Makefile:70: test] Terminated
```

### Information Gaps

- Exact CI environment details (CPU, load, test runner parallelism).
- Whether the hang reproduces locally with the same commands.
- Whether `test_overflow_policy_timeout` is running in the same process as the
  reported hanging tests (feature set + ordering).

---

## Hypotheses

### H1: The blocking Python formatter holds the GIL indefinitely, stalling later Python tests

**Claim**: `blocking_formatter` waits on `release_worker` while holding the GIL
inside the Rust worker thread, preventing other Python-bound tests from
executing and causing the suite to appear hung.

**Plausibility**: High — the formatter is a Python callable executed via
`Python::with_gil`, and the wait is now unbounded.

**Prediction**: If true, Python tests should stall only when the blocking
formatter is invoked and `release_worker` remains unset for a prolonged period.

#### Falsification Plan

| Step | Action | Expected Negative Result |
|------|--------|--------------------------|
| 1 | Run only `tests/test_file_handler.py::test_overflow_policy_timeout` with `PYTHONFAULTHANDLER=1` and `-s` to check for GIL-related waits. | Test completes quickly and no GIL wait is visible. |
| 2 | Run the Python test subset (`cargo test --features python python::tests::...` or equivalent) with `RUST_TEST_THREADS=1` and without the timeout test (temporarily skip) to see if hangs disappear. | Python tests still hang without the timeout test. |

**Tooling**: `pytest -k overflow_policy_timeout -vv -s`, `cargo test --features python -- --nocapture`, `RUST_TEST_THREADS=1`.

**Confidence on falsification**: Medium-High.

---

### H2: The worker thread stays blocked in `blocking_formatter`, preventing handler shutdown and leaking threads that block later Rust tests

**Claim**: The worker thread remains blocked in the formatter after the test,
so `handler.close()` times out and leaves a live worker thread that interferes
with later tests (especially rotating handler tests that rely on clean thread
shutdown).

**Plausibility**: Medium — the test now uses an unbounded wait; if any path
exits before `release_worker.set()`, the worker is stuck.

**Prediction**: If true, the test process should show a live worker thread
stack blocked in `threading.Event.wait` after the test completes.

#### Falsification Plan

| Step | Action | Expected Negative Result |
|------|--------|--------------------------|
| 1 | Run the single test with `RUST_LOG` or debug logging to confirm the worker exits on close. | Logs confirm worker shutdown and thread exit. |
| 2 | Use a debugger or `PYTHONFAULTHANDLER`/`faulthandler.dump_traceback_later` to inspect threads after the test. | No worker thread is blocked in `Event.wait`. |

**Tooling**: `pytest -k overflow_policy_timeout -vv -s`, `faulthandler`, logging instrumentation in `blocking_formatter`.

**Confidence on falsification**: Medium.

---

### H3: Test suite ordering + parallelism exposes a pre-existing rotating handler slowdown that is unrelated to the new test

**Claim**: The rotating handler tests are slow or stuck due to file system or
I/O contention in the CI environment, and the new test merely shifts timing to
trigger the hang.

**Plausibility**: Medium — the reported hang occurs in rotating handler tests,
not directly in the timeout test itself.

**Prediction**: If true, the rotating handler tests can hang even when the
timeout test is skipped or reverted.

#### Falsification Plan

| Step | Action | Expected Negative Result |
|------|--------|--------------------------|
| 1 | Run only the rotating handler tests in isolation with `RUST_TEST_THREADS=1`. | Rotating handler tests complete quickly without hang. |
| 2 | Re-run with the timeout test skipped to compare total runtime. | Runtime remains long even without the timeout test. |

**Tooling**: `cargo test handlers::rotating::tests::behaviour -- --nocapture`, `RUST_TEST_THREADS=1`.

**Confidence on falsification**: Medium.

---

## Recommended Execution Order

1. **H1** — Fastest and most likely; directly tests the new blocking formatter
   path.
2. **H2** — Confirms whether worker threads are leaking across tests.
3. **H3** — Validates whether the hang is independent of the recent change.

## Termination Criteria

- **Root cause identified**: One hypothesis remains consistent while others are
  falsified.
- **Escalation trigger**: All hypotheses falsified; capture fresh logs and add
  new hypotheses based on the new evidence.

## Notes for Executing Agent

- Prefer serial test execution (`RUST_TEST_THREADS=1`, `pytest -n 0`) to isolate
  interference.
- Capture thread traces on hang using `faulthandler.dump_traceback_later` for
  Python and `RUST_BACKTRACE=1` for Rust.
- If the hang is confirmed to be caused by the blocking formatter, consider
  alternative synchronisation (e.g., explicit barrier + bounded wait) that
  preserves determinism without indefinite blocking.
